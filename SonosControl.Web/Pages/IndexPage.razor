@page "/"
@using System.Text.RegularExpressions
@using System.Linq
@using Radzen.Blazor.Rendering
@using SonosControl.DAL.Interfaces
@using SonosControl.DAL.Models
@using SonosControl.Web.Data
@using SonosControl.Web.Models
@using SonosControl.Web.Pages.Index.Components
@using SonosControl.Web.Services
@inject ApplicationDbContext Db
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject INotificationService NotificationService
@inject IConfiguration Configuration
@inject ILogger<IndexPage> Logger
@inject IMetricsCollector MetricsCollector
@attribute [Authorize(Roles = "admin,operator,superadmin")]
@implements IAsyncDisposable

<PageTitle>Sonos Control</PageTitle>

@if (_settings is not null)
{
    <div class="container dashboard-shell">
        <div class="card dashboard-panel surface-0">
            <div class="card-body">
                <div class="d-flex flex-column flex-lg-row align-items-start justify-content-between mb-4 gap-3">
                    <div>
                        <h3 class="mb-1">üéõÔ∏è Sonos Control Panel</h3>
                        <p class="text-muted mb-0">Manage playback, queue, and curated sources for your Sonos system.</p>
                    </div>
                    <div class="d-flex flex-column align-items-start align-items-lg-end gap-2">
                        @if (IsRefreshStale)
                        {
                            <span class="badge text-bg-warning index-refresh-badge">Live updates delayed</span>
                        }
                        <small class="text-muted index-refresh-meta">@RefreshTelemetryLabel</small>
                    </div>
                </div>

                @if (!string.IsNullOrWhiteSpace(_commandStatusMessage))
                {
                    <div class="alert @(_commandStatusIsError ? "alert-danger" : "alert-success") py-2 mb-3 index-command-status" role="status" aria-live="polite">
                        @_commandStatusMessage
                    </div>
                }

                <div class="dashboard-grid">
                    <div class="playback-column">
                        @if (_settings.Speakers.Any())
                        {
                            <div class="mb-3">
                                <label for="activeSpeakerSelect" class="form-label text-muted small">Active Speaker</label>
                                <div class="d-flex flex-wrap gap-2 align-items-center speaker-controls">
                                    <select id="activeSpeakerSelect" class="form-select flex-grow-1 speaker-controls__select" @bind="SelectedSpeakerIp">
                                        @foreach (var speaker in _settings.Speakers)
                                        {
                                            <option value="@speaker.IpAddress">@speaker.Name</option>
                                        }
                                    </select>
                                    <div class="btn-group speaker-controls__pair">
                                        <button class="btn btn-outline-primary" @onclick="OpenGroupModal" disabled="@(_isGrouping || _isUngrouping)" title="Group speakers">
                                            @if (_isGrouping)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                            }
                                            else
                                            {
                                                <span>üîó Group</span>
                                            }
                                        </button>
                                        <button class="btn btn-outline-secondary" @onclick="UngroupCurrent" disabled="@(_isGrouping || _isUngrouping)" title="Ungroup active speaker" aria-label="Ungroup active speaker">
                                            @if (_isUngrouping)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                            }
                                            else
                                            {
                                                <span>‚õìÔ∏è‚Äçüí•</span>
                                            }
                                        </button>
                                    </div>
                                    <button class="btn btn-outline-info speaker-controls__sync" @onclick="SyncPlay" disabled="@_isSyncing" title="Play current media on all speakers">
                                        @if (_isSyncing)
                                        {
                                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                            <span class="visually-hidden">Syncing...</span>
                                        }
                                        else
                                        {
                                            <span>Sync Play</span>
                                        }
                                    </button>
                                </div>
                            </div>
                        }

                        <PlaybackCard
                            IsPlaying="_isPlaying"
                            IsLoading="_isMainPlaybackLoading"
                            ShowNextTrack="_isPlaying && _isSpotifyPlaying"
                            IsNextTrackLoading="_isNextTrackLoading"
                            Volume="Volume"
                            MaxVolumeLimit="MaxVolumeLimit"
                            GradientStyle="PlaybackCardStyle"
                            TogglePlay="Play"
                            VolumeChanged="@(value => Volume = value)"
                            OnOpenTimer="OpenTimerModal"
                            OnNextTrack="NextTrack" />

                        @if (_timerEndTimeUtc is not null)
                        {
                            var localStopTime = _timerEndTimeUtc.Value.ToLocalTime();
                            <div class="alert alert-info timed-playback-alert d-flex justify-content-between align-items-center mb-3">
                                <div>
                                    <strong>Timed Playback Active</strong>
                                    <p class="mb-0 text-muted">@(_timerSelectionName ?? "Playback") will stop at @localStopTime.ToString("t").</p>
                                </div>
                                <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="CancelTimedPlayback">Cancel</button>
                            </div>
                        }

                        <div class="card currently-playing-card">
                            <div class="card-body d-flex flex-column flex-md-row align-items-start gap-3">
                                @if (!string.IsNullOrWhiteSpace(currentTrackArtUrl))
                                {
                                    <img src="@currentTrackArtUrl" alt="@($"Album art for {currentlyPlaying}")" class="img-fluid rounded" style="max-width: 120px; max-height: 120px; object-fit: cover;" />
                                }
                                else
                                {
                                    <div class="display-5" aria-hidden="true">üéµ</div>
                                }
                                <div class="flex-grow-1">
                                    <h5 class="mb-2">Currently Playing</h5>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Station:</strong> @currentStationDisplay</p>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Track:</strong> @currentlyPlaying</p>
                                    @if (!string.IsNullOrWhiteSpace(trackProgress))
                                    {
                                        <p class="mb-0 text-muted currently-playing-text"><strong>Time:</strong> @trackProgress</p>
                                    }
                                </div>
                            </div>
                        </div>

                        <QueuePanel
                            Items="_queueItems"
                            IsLoading="_isQueueLoading"
                            HasMore="QueueHasMore"
                            AutoRefreshEnabled="_queueAutoRefreshEnabled"
                            RefreshIntervalSeconds="_queueRefreshIntervalSeconds"
                            RefreshIntervals="_queueRefreshOptions"
                            ErrorMessage="@_queueErrorMessage"
                            Refresh="HandleQueueRefresh"
                            LoadMore="LoadMoreQueueItems"
                            AutoRefreshChanged="HandleQueueAutoRefreshChanged"
                            RefreshIntervalChanged="HandleQueueRefreshIntervalChanged"
                            FormatItem="FormatQueueItem" />
                    </div>
                    <div class="info-column">
                        <SectionCard Title="Speaker Status" Icon="üì¢">
                            <ChildContent>
                                <ul class="list-group list-group-flush media-list">
                                    @if (_speakerStatuses.Any())
                                    {
                                        var roots = _speakerStatuses
                                            .Where(s => string.IsNullOrEmpty(s.MasterUuid) || !_speakerStatuses.Any(m => m.Uuid == s.MasterUuid))
                                            .OrderBy(s => s.Name);

                                        foreach (var root in roots)
                                        {
                                            <li class="list-group-item d-flex justify-content-between align-items-center speaker-status-item">
                                                <div class="d-flex align-items-center">
                                                    <span class="me-2 status-indicator @(root.IsPlaying ? "status-playing" : "status-paused")"></span>
                                                    <div>
                                                        <span class="fw-bold">@root.Name</span>
                                                        @if (root.IsPlaying && !string.IsNullOrWhiteSpace(root.Media))
                                                        {
                                                            <br/>
                                                            <small class="text-muted">@root.Media</small>
                                                        }
                                                    </div>
                                                </div>
                                                <span class="badge rounded-pill text-uppercase @(root.IsPlaying ? "text-bg-success" : "text-bg-secondary")">
                                                    @(root.IsPlaying ? "Playing" : "Paused")
                                                </span>
                                            </li>

                                            var children = _speakerStatuses.Where(s => s.MasterUuid == root.Uuid).OrderBy(s => s.Name);
                                            foreach (var child in children)
                                            {
                                                <li class="list-group-item d-flex justify-content-between align-items-center border-start border-3 border-secondary speaker-status-item speaker-status-item--child" style="background-color: var(--surface-2);">
                                                    <div class="d-flex align-items-center">
                                                        <span class="me-2 text-muted">‚Ü≥</span>
                                                        <span class="me-2 status-indicator @(child.IsPlaying ? "status-playing" : "status-paused")"></span>
                                                        <div>
                                                            <span class="fw-bold">@child.Name</span>
                                                            <br/>
                                                            <small class="text-muted">Linked to @root.Name</small>
                                                        </div>
                                                    </div>
                                                    <span class="badge rounded-pill text-uppercase @(child.IsPlaying ? "text-bg-success" : "text-bg-secondary")">
                                                        @(child.IsPlaying ? "Playing" : "Paused")
                                                    </span>
                                                </li>
                                            }
                                        }
                                    }
                                    else
                                    {
                                        <li class="list-group-item">No speakers to display.</li>
                                    }
                                </ul>
                            </ChildContent>
                        </SectionCard>
                        <hr/>
                        <SectionCard Title="Media Sources" Icon="üé∂">
                            <ChildContent>
                                <MediaTabs @bind-ActiveTab="_activeMediaTab">
                                    <StationsContent>
                                        @{
                                            var stations = _stations;
                                            <div class="d-flex justify-content-between align-items-center mb-3 media-list-header">
                                                <h5 class="mb-0">Saved Stations</h5>
                                                <div class="media-list-header__actions">
                                                    <button class="btn btn-sm btn-outline-secondary" @onclick="ShuffleStation" title="Play Random Station" aria-label="Play Random Station" disabled="@_isShuffleLoading">
                                                        @if (_isShuffleLoading)
                                                        {
                                                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                        }
                                                        else
                                                        {
                                                            <span>üîÄ</span>
                                                        }
                                                    </button>
                                                    <button class="btn btn-sm btn-primary" @onclick="ShowAddStationModal" aria-label="Add Station">‚ûï Add</button>
                                                </div>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (stations.Any())
                                                {
                                                    @foreach (var station in stations)
                                                    {
                                                        <li class="list-group-item media-list__item @(IsCurrentlyPlaying(station.Url) ? "active-media" : "")">
                                                            <span class="media-list__name">@station.Name</span>
                                                            <div class="media-actions media-list__actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(station.Url, "station"))" aria-label="Play @station.Name" disabled="@(_loadingMediaUrl == station.Url)">
                                                                    @if (_loadingMediaUrl == station.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveStation(station))" aria-label="Remove @station.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No stations saved.</li>
                                                }
                                            </ul>
                                        }
                                    </StationsContent>
                                    <SpotifyContent>
                                        @{
                                            var tracks = _tracks;
                                            <div class="d-flex justify-content-between align-items-center mb-3 media-list-header">
                                                <h5 class="mb-0">Saved Spotify</h5>
                                                <div class="media-list-header__actions">
                                                    <button class="btn btn-sm btn-primary" @onclick="ShowAddSpotifyModal" aria-label="Add Spotify Track">‚ûï Add</button>
                                                </div>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (tracks.Any())
                                                {
                                                    @foreach (var track in tracks)
                                                    {
                                                        <li class="list-group-item media-list__item @(IsCurrentlyPlaying(track.Url) ? "active-media" : "")">
                                                            <span class="media-list__name">@track.Name</span>
                                                            <div class="media-actions media-list__actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(track.Url, "spotify"))" aria-label="Play @track.Name" disabled="@(_loadingMediaUrl == track.Url)">
                                                                    @if (_loadingMediaUrl == track.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveSpotifyTrack(track))" aria-label="Remove @track.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No Spotify tracks saved.</li>
                                                }
                                            </ul>
                                        }
                                    </SpotifyContent>
                                    <YouTubeContent>
                                        @{
                                            var collections = _youTubeCollections;
                                            <div class="d-flex justify-content-between align-items-center mb-3 media-list-header">
                                                <h5 class="mb-0">Saved YouTube</h5>
                                                <div class="media-list-header__actions">
                                                    <button class="btn btn-sm btn-primary" @onclick="ShowAddYouTubeModal" aria-label="Add YouTube Music Collection">‚ûï Add</button>
                                                </div>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (collections.Any())
                                                {
                                                    @foreach (var collection in collections)
                                                    {
                                                        <li class="list-group-item media-list__item @(IsCurrentlyPlaying(collection.Url) ? "active-media" : "")">
                                                            <span class="media-list__name">@collection.Name</span>
                                                            <div class="media-actions media-list__actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(collection.Url, "youtube"))" aria-label="Play @collection.Name" disabled="@(_loadingMediaUrl == collection.Url)">
                                                                    @if (_loadingMediaUrl == collection.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveYouTubeMusicEntry(collection))" aria-label="Remove @collection.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No YouTube collections saved.</li>
                                                }
                                            </ul>
                                        }
                                    </YouTubeContent>
                                </MediaTabs>
                        
                                <div class="mt-3">
                                    <h5 class="mb-2">üéß Play Spotify URL</h5>
                                    <div class="input-group">
                                        <input type="text"
                                               class="form-control"
                                               @bind-value="spotifyUrl"
                                               @bind-value:event="oninput"
                                               @onkeyup="HandleKeyPress"
                                               placeholder="Enter Spotify URL"
                                               aria-label="Spotify URL" />
                                        <button class="btn btn-primary" type="button" @onclick="SubmitSpotifyUrl" disabled="@_isSpotifyUrlLoading">
                                            @if (_isSpotifyUrlLoading)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                <span class="visually-hidden">Loading...</span>
                                            }
                                            else
                                            {
                                                <span>Play</span>
                                            }
                                        </button>
                                    </div>
                                </div>
                            </ChildContent>
                        </SectionCard>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<TimerModal
    Show="isTimerModalOpen"
    OnClose="CloseTimerModal"
    OnStart="StartTimedPlayback"
    TimerMinutes="timerMinutes"
    TimerMinutesChanged="value => timerMinutes = value"
    SelectedSource="timerSelection"
    SelectedSourceChanged="value => timerSelection = value"
    Stations="_stations"
    SpotifyTracks="_tracks"
    YouTubeCollections="_youTubeCollections"
    ErrorMessage="@timerErrorMessage" />

<AddMediaItemModal @ref="_addMediaItemModal" OnSave="SaveNewMediaItem" ErrorMessage="@_addModalError" OnClose="() => _addModalError = null"/>

<GroupSpeakersModal Show="isGroupModalOpen"
                    Speakers="@(_settings?.Speakers ?? new())"
                    MasterIp="@SelectedSpeakerIp"
                    IsLoading="@_isGrouping"
                    OnClose="CloseGroupModal"
                    OnGroup="HandleCreateGroup" />

@code {
    public class SpeakerStatusViewModel
    {
        public string? Name { get; set; }
        public string? IpAddress { get; set; }
        public string? Uuid { get; set; }
        public bool IsPlaying { get; set; }
        public string? Media { get; set; }
        public string? MasterUuid { get; set; }
        public string? RawStationUrl { get; set; }
    }

    private const int FastRefreshIntervalSeconds = 3;
    private const int DefaultSlowLaneSeconds = 15;
    private const int QueuePageSize = 30;
    private static readonly int[] _queueRefreshOptions = new[] { 15, 30, 60 };

    private readonly object _refreshSync = new();
    private readonly SemaphoreSlim _refreshLoopLock = new(1, 1);
    private CancellationTokenSource _disposeCts = new();
    private CancellationTokenSource? _activeRefreshCts;
    private bool _refreshPending;
    private bool _refreshPendingSlowLane;
    private DateTime? _lastSuccessfulRefreshUtc;
    private DateTime? _lastSlowLaneRefreshUtc;
    private int _consecutiveRefreshFailures;
    private bool _isRefreshRunning;

    private readonly SemaphoreSlim _queueRefreshLock = new(1, 1);
    private CancellationTokenSource? _queueRefreshCts;
    private Timer? _queueRefreshTimer;
    private IReadOnlyList<SonosQueueItem> _queueItems = Array.Empty<SonosQueueItem>();
    private bool _isQueueLoading;
    private bool _queueAutoRefreshEnabled = true;
    private int _queueRefreshIntervalSeconds = 30;
    private int _queueStartIndex;
    private int _queueTotalMatches;
    private string? _queueErrorMessage;
    private string? _commandStatusMessage;
    private bool _commandStatusIsError;
    private CancellationTokenSource? _commandStatusCts;

    private List<SpeakerStatusViewModel> _speakerStatuses = new();
    private SonosSettings? _settings;
    private bool _isPlaying;
    private bool _isSyncing;
    private bool _isGrouping;
    private bool _isUngrouping;
    private bool isGroupModalOpen;
    private bool _isMainPlaybackLoading;
    private bool _isNextTrackLoading;
    private bool _isSpotifyUrlLoading;
    private string? _loadingMediaUrl;
    private bool _isSpotifyPlaying;
    private string? spotifyUrl;
    private string? _selectedSpeakerIp;

    private string SelectedSpeakerIp
    {
        get => _selectedSpeakerIp ?? _settings?.IP_Adress ?? "";
        set
        {
            if (_selectedSpeakerIp != value)
            { 
                _selectedSpeakerIp = value;
                if (_settings != null)
                {
                    _ = UpdateSpeakerRelatedData(value);
                }
            }
        }
    }

    private async Task UpdateSpeakerRelatedData(string newIpAddress)
    {
        if (_settings is null)
        {
            return;
        }

        _settings.IP_Adress = newIpAddress;
        await SaveSettings();

        try
        {
            _settings.Volume = await _uow.SonosConnectorRepo.GetVolume(newIpAddress);
        }
        catch
        {
            // Ignore if speaker is offline or returns error
            _settings.Volume = 0; // Default to 0 or last known good if error
        }

        // Refresh data for the new speaker
        await RequestPageRefreshAsync(forceSlowLane: true);
        await RefreshQueueAsync(reset: true);
    }

    // New state for tabs and modal
    private string _activeMediaTab = "stations";
    private AddMediaItemModal _addMediaItemModal = default!;
    private string? _addModalError;


    private int Volume
    {
        get
        {
            if (_settings is null)
            {
                return 0;
            }

            var limit = MaxVolumeLimit;
            return Math.Min(_settings.Volume, limit);
        }
        set
        {
            if (_settings is null)
            {
                return;
            }

            var limit = MaxVolumeLimit;
            var clamped = Math.Clamp(value, 0, limit);

            if (_settings.Volume == clamped)
            {
                return;
            }

            _settings.Volume = clamped;
            _ = _uow.SonosConnectorRepo.SetVolume(_settings.IP_Adress, clamped);
            _ = SaveSettings();
        }
    }

    private int MaxVolumeLimit => Math.Clamp(_settings?.MaxVolume ?? 100, 0, 100);

    private string? PlaybackCardStyle => !_isPlaying || _settings is null
        ? null
        : $"background: linear-gradient(135deg, {NormalizeColor(_settings.NowPlayingGradientStartColor, SonosSettings.DefaultNowPlayingGradientStartColor)} 0%, {NormalizeColor(_settings.NowPlayingGradientMidColor, SonosSettings.DefaultNowPlayingGradientMidColor)} 55%, {NormalizeColor(_settings.NowPlayingGradientEndColor, SonosSettings.DefaultNowPlayingGradientEndColor)} 100%);";

    private bool isAuthenticated;

    private bool isTimerModalOpen;
    private int timerMinutes = 60;
    private string? timerSelection;
    private string? timerErrorMessage;
    private CancellationTokenSource? _playbackTimerCts;
    private DateTime? _timerEndTimeUtc;
    private string? _timerSelectionName;

    private string currentStationUrl = "Loading...";
    private string currentStationDisplay = "Loading...";

    private string currentlyPlaying = "Loading...";
    private string? currentTrackArtUrl;
    private string trackProgress = "";
    private Timer? _stationUpdateTimer;

    private bool QueueHasMore => _queueStartIndex < _queueTotalMatches;
    private bool IsRefreshStale => _consecutiveRefreshFailures >= 2;
    private int SlowLaneSeconds => Math.Clamp(Configuration.GetValue<int?>("Dashboard:SlowLaneSeconds") ?? DefaultSlowLaneSeconds, 10, 120);
    private string RefreshTelemetryLabel
    {
        get
        {
            if (_isRefreshRunning)
            {
                return "Syncing live state...";
            }

            if (!_lastSuccessfulRefreshUtc.HasValue)
            {
                return "Waiting for first successful refresh";
            }

            var elapsed = DateTime.UtcNow - _lastSuccessfulRefreshUtc.Value;
            if (elapsed.TotalSeconds < 5)
            {
                return "Updated just now";
            }

            return $"Last update {Math.Round(elapsed.TotalSeconds)}s ago";
        }
    }

    private List<TuneInStation> _stations =>
        (_settings?.Stations ?? new List<TuneInStation>())
        .OrderBy(s => s.Name)
        .ToList();

    private List<SpotifyObject> _tracks =>
        (_settings?.SpotifyTracks ?? new List<SpotifyObject>())
        .OrderBy(t => t.Name)
        .ToList();

    private List<YouTubeMusicObject> _youTubeCollections =>
        (_settings?.YouTubeMusicCollections ?? new List<YouTubeMusicObject>())
        .OrderBy(t => t.Name)
        .ToList();

    private async Task RequestPageRefreshAsync(bool forceSlowLane = false)
    {
        lock (_refreshSync)
        {
            _refreshPending = true;
            _refreshPendingSlowLane |= forceSlowLane;
            _activeRefreshCts?.Cancel();
        }

        if (!await _refreshLoopLock.WaitAsync(0))
        {
            return;
        }

        try
        {
            while (true)
            {
                bool runSlowLane;
                CancellationToken token;

                lock (_refreshSync)
                {
                    if (!_refreshPending)
                    {
                        break;
                    }

                    _refreshPending = false;
                    runSlowLane = _refreshPendingSlowLane;
                    _refreshPendingSlowLane = false;

                    _activeRefreshCts?.Dispose();
                    _activeRefreshCts = CancellationTokenSource.CreateLinkedTokenSource(_disposeCts.Token);
                    token = _activeRefreshCts.Token;
                }

                _isRefreshRunning = true;
                await UpdatePageDataAsync(runSlowLane, token);

                if (_disposeCts.IsCancellationRequested)
                {
                    break;
                }
            }
        }
        finally
        {
            _isRefreshRunning = false;

            lock (_refreshSync)
            {
                _activeRefreshCts?.Dispose();
                _activeRefreshCts = null;
            }

            _refreshLoopLock.Release();
        }
    }

    private async Task UpdatePageDataAsync(bool forceSlowLane = false, CancellationToken cancellationToken = default)
    {
        var cycleStartUtc = DateTime.UtcNow;
        var runSlowLane = forceSlowLane || ShouldRunSlowLane(cycleStartUtc);

        try
        {
            cancellationToken.ThrowIfCancellationRequested();

            var updateStatusesTask = UpdateSpeakerStatuses(cancellationToken);
            var selectedSpeakerTask = runSlowLane
                ? LoadCurrentStation(cancellationToken)
                : LoadCurrentStationFast(cancellationToken);

            await Task.WhenAll(updateStatusesTask, selectedSpeakerTask);
            PopulateSelectedSpeakerMedia();

            _lastSuccessfulRefreshUtc = DateTime.UtcNow;
            if (runSlowLane)
            {
                _lastSlowLaneRefreshUtc = _lastSuccessfulRefreshUtc;
            }

            _consecutiveRefreshFailures = 0;
            MetricsCollector.RecordDashboardRefreshResult(success: true, runSlowLane, DateTime.UtcNow - cycleStartUtc);
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            return;
        }
        catch (Exception ex)
        {
            _consecutiveRefreshFailures++;
            Logger.LogWarning(ex, "Dashboard refresh cycle failed.");
            MetricsCollector.RecordDashboardRefreshResult(success: false, runSlowLane, DateTime.UtcNow - cycleStartUtc);
        }

        if (!_disposeCts.IsCancellationRequested)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private bool ShouldRunSlowLane(DateTime cycleStartUtc)
    {
        if (!_lastSlowLaneRefreshUtc.HasValue)
        {
            return true;
        }

        return cycleStartUtc - _lastSlowLaneRefreshUtc.Value >= TimeSpan.FromSeconds(SlowLaneSeconds);
    }

    private void UpdatePageData(object? _ = null)
    {
        _ = InvokeAsync(() => RequestPageRefreshAsync());
    }

    private async Task UpdateSpeakerStatuses(CancellationToken cancellationToken)
    {
        if (_settings?.Speakers == null)
        {
            _speakerStatuses = new();
            return;
        }

        var tasks = _settings.Speakers.Select(speaker => BuildSpeakerStatusAsync(speaker, cancellationToken)).ToList();
        _speakerStatuses = (await Task.WhenAll(tasks)).ToList();
    }

    private async Task<SpeakerStatusViewModel> BuildSpeakerStatusAsync(SonosSpeaker speaker, CancellationToken cancellationToken)
    {
        try
        {
            var isPlayingTask = _uow.SonosConnectorRepo.IsPlaying(speaker.IpAddress);
            var rawStationUrlTask = _uow.SonosConnectorRepo.GetCurrentStationAsync(speaker.IpAddress, cancellationToken);
            await Task.WhenAll(isPlayingTask, rawStationUrlTask);

            var isPlaying = await isPlayingTask;
            var rawStationUrl = await rawStationUrlTask;
            var normalizedStationUrl = NormalizeStationUrl(rawStationUrl);
            var masterUuid = TryExtractMasterUuid(rawStationUrl);

            if (speaker.IpAddress == SelectedSpeakerIp)
            {
                _isPlaying = isPlaying;
            }

            return new SpeakerStatusViewModel
            {
                Name = speaker.Name,
                IpAddress = speaker.IpAddress,
                Uuid = speaker.Uuid,
                IsPlaying = isPlaying,
                Media = speaker.IpAddress == SelectedSpeakerIp
                    ? null
                    : ResolveSpeakerMedia(isPlaying, normalizedStationUrl, masterUuid),
                MasterUuid = masterUuid,
                RawStationUrl = rawStationUrl
            };
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            throw;
        }
        catch
        {
            return new SpeakerStatusViewModel
            {
                Name = speaker.Name,
                IpAddress = speaker.IpAddress,
                Uuid = speaker.Uuid,
                IsPlaying = false,
                Media = "Offline",
                MasterUuid = null,
                RawStationUrl = null
            };
        }
    }

    private string ResolveSpeakerMedia(bool isPlaying, string normalizedStationUrl, string? masterUuid)
    {
        if (!isPlaying)
        {
            return masterUuid is null ? string.Empty : "Grouped";
        }

        if (masterUuid is not null)
        {
            return "Grouped";
        }

        if (normalizedStationUrl.Contains("spotify", StringComparison.OrdinalIgnoreCase))
        {
            return "Spotify";
        }

        if (normalizedStationUrl.Contains("youtube", StringComparison.OrdinalIgnoreCase))
        {
            return "YouTube Music";
        }

        var matched = _stations.FirstOrDefault(s =>
            !string.IsNullOrWhiteSpace(s.Url) &&
            normalizedStationUrl.Contains(s.Url, StringComparison.OrdinalIgnoreCase));

        return matched?.Name ?? "Playing stream";
    }

    private static string? TryExtractMasterUuid(string? rawStationUrl)
    {
        if (string.IsNullOrWhiteSpace(rawStationUrl) || !rawStationUrl.StartsWith("x-rincon-group:", StringComparison.OrdinalIgnoreCase))
        {
            return null;
        }

        var match = Regex.Match(rawStationUrl, @"(uuid:RINCON_[A-F0-9]+)");
        return match.Success ? match.Groups[1].Value : null;
    }

    private static string NormalizeStationUrl(string? rawStationUrl)
        => SonosControl.DAL.SonosUrlHelper.NormalizeStationUrl(rawStationUrl);

    private async Task LoadCurrentStation(CancellationToken cancellationToken)
    {
        if (_settings is null)
        {
            return;
        }

        var stationTask = _uow.SonosConnectorRepo.GetCurrentStationAsync(_settings.IP_Adress, cancellationToken);
        var trackInfoTask = _uow.SonosConnectorRepo.GetTrackInfoAsync(_settings.IP_Adress, cancellationToken);
        var progressTask = _uow.SonosConnectorRepo.GetTrackProgressAsync(_settings.IP_Adress, cancellationToken);

        await Task.WhenAll(stationTask, trackInfoTask, progressTask);

        currentStationUrl = NormalizeStationUrl(await stationTask);
        currentStationDisplay = ResolveStationDisplay(currentStationUrl);
        _isSpotifyPlaying = currentStationDisplay.Equals("Spotify", StringComparison.OrdinalIgnoreCase);

        var trackInfo = await trackInfoTask;
        if (trackInfo != null && trackInfo.IsValidMetadata())
        {
            currentlyPlaying = trackInfo.GetDisplayString();
            currentTrackArtUrl = trackInfo.AlbumArtUri;
        }
        else
        {
            currentlyPlaying = "No metadata available";
            currentTrackArtUrl = null;
        }

        var progress = await progressTask;
        trackProgress = FormatTrackProgress(progress.Position, progress.Duration);
    }

    private async Task LoadCurrentStationFast(CancellationToken cancellationToken)
    {
        if (_settings is null)
        {
            return;
        }

        var stationTask = _uow.SonosConnectorRepo.GetCurrentStationAsync(_settings.IP_Adress, cancellationToken);
        var progressTask = _uow.SonosConnectorRepo.GetTrackProgressAsync(_settings.IP_Adress, cancellationToken);

        await Task.WhenAll(stationTask, progressTask);

        currentStationUrl = NormalizeStationUrl(await stationTask);
        currentStationDisplay = ResolveStationDisplay(currentStationUrl);
        _isSpotifyPlaying = currentStationDisplay.Equals("Spotify", StringComparison.OrdinalIgnoreCase);

        var progress = await progressTask;
        trackProgress = FormatTrackProgress(progress.Position, progress.Duration);
    }

    private string ResolveStationDisplay(string normalizedStationUrl)
    {
        if (string.IsNullOrWhiteSpace(normalizedStationUrl))
        {
            return "Unknown";
        }

        if (normalizedStationUrl.Contains("spotify", StringComparison.OrdinalIgnoreCase))
        {
            return "Spotify";
        }

        if (normalizedStationUrl.Contains("youtube", StringComparison.OrdinalIgnoreCase))
        {
            return "YouTube Music";
        }

        var matched = _stations.FirstOrDefault(s =>
            !string.IsNullOrWhiteSpace(s.Url) &&
            normalizedStationUrl.Contains(s.Url, StringComparison.OrdinalIgnoreCase));

        return matched?.Name ?? normalizedStationUrl;
    }

    private static string FormatTrackProgress(TimeSpan position, TimeSpan duration)
    {
        if (duration == TimeSpan.Zero)
        {
            return position == TimeSpan.Zero
                ? string.Empty
                : $"{position:mm\\:ss}";
        }

        return $"{position:mm\\:ss} / {duration:mm\\:ss}";
    }

    private void PopulateSelectedSpeakerMedia()
    {
        var selectedStatus = _speakerStatuses.FirstOrDefault(s => s.IpAddress == SelectedSpeakerIp);
        if (selectedStatus == null)
        {
            return;
        }

        if (!selectedStatus.IsPlaying)
        {
            selectedStatus.Media = selectedStatus.MasterUuid is null ? string.Empty : "Grouped";
            return;
        }

        var isTrackValid = !string.IsNullOrWhiteSpace(currentlyPlaying) &&
                           !currentlyPlaying.Equals("No metadata available", StringComparison.OrdinalIgnoreCase);

        if (isTrackValid)
        {
            selectedStatus.Media = currentlyPlaying;
            return;
        }

        selectedStatus.Media = ResolveSpeakerMedia(true, NormalizeStationUrl(selectedStatus.RawStationUrl), selectedStatus.MasterUuid);
    }
    
    private bool IsCurrentlyPlaying(string url)
    {
        if (string.IsNullOrEmpty(url) || string.IsNullOrEmpty(currentStationUrl))
        {
            return false;
        }
        // Normalize and compare, this might need to be more robust
        return currentStationUrl.Contains(url, StringComparison.OrdinalIgnoreCase);
    }

    private Task HandleQueueRefresh()
        => RefreshQueueAsync(reset: true);

    private Task LoadMoreQueueItems()
        => RefreshQueueAsync(reset: false);

    private Task HandleQueueAutoRefreshChanged(bool enabled)
    {
        _queueAutoRefreshEnabled = enabled;
        ConfigureQueueAutoRefreshTimer();
        return Task.CompletedTask;
    }

    private async Task HandleQueueRefreshIntervalChanged(int seconds)
    {
        if (!_queueRefreshOptions.Contains(seconds))
        {
            return;
        }

        if (_queueRefreshIntervalSeconds == seconds)
        {
            return;
        }

        _queueRefreshIntervalSeconds = seconds;
        ConfigureQueueAutoRefreshTimer();

        if (_queueAutoRefreshEnabled)
        {
            await RefreshQueueAsync(reset: true);
        }
    }

    private void ConfigureQueueAutoRefreshTimer()
    {
        _queueRefreshTimer?.Dispose();
        _queueRefreshTimer = null;

        if (!_queueAutoRefreshEnabled || _queueRefreshIntervalSeconds <= 0)
        {
            return;
        }

        _queueRefreshTimer = new Timer(
            _ => _ = InvokeAsync(() => RefreshQueueAsync(reset: true)),
            null,
            TimeSpan.FromSeconds(_queueRefreshIntervalSeconds),
            TimeSpan.FromSeconds(_queueRefreshIntervalSeconds));
    }

    private async Task RefreshQueueAsync(bool reset)
    {
        if (_settings is null || string.IsNullOrWhiteSpace(SelectedSpeakerIp))
        {
            _queueItems = Array.Empty<SonosQueueItem>();
            _queueStartIndex = 0;
            _queueTotalMatches = 0;
            _queueErrorMessage = null;
            return;
        }

        if (!await _queueRefreshLock.WaitAsync(0))
        {
            return;
        }

        CancellationTokenSource? previousCts = null;
        try
        {
            previousCts = _queueRefreshCts;
            _queueRefreshCts = CancellationTokenSource.CreateLinkedTokenSource(_disposeCts.Token);
            previousCts?.Cancel();

            _queueErrorMessage = null;
            _isQueueLoading = true;
            await InvokeAsync(StateHasChanged);

            var token = _queueRefreshCts.Token;
            var startIndex = reset ? 0 : _queueStartIndex;
            var queuePage = await _uow.SonosConnectorRepo.GetQueue(SelectedSpeakerIp, startIndex, QueuePageSize, token);

            if (reset)
            {
                _queueItems = queuePage.Items.ToList();
            }
            else
            {
                _queueItems = _queueItems.Concat(queuePage.Items).ToList();
            }

            _queueStartIndex = queuePage.StartIndex + queuePage.NumberReturned;
            _queueTotalMatches = queuePage.TotalMatches;
        }
        catch (OperationCanceledException) when (_queueRefreshCts?.IsCancellationRequested == true)
        {
        }
        catch (Exception ex)
        {
            _queueErrorMessage = "Queue refresh failed. Please retry.";
            Logger.LogWarning(ex, "Queue refresh failed for speaker {SpeakerIp}.", SelectedSpeakerIp);
            MetricsCollector.IncrementSonosCommandError("queue_refresh");
        }
        finally
        {
            previousCts?.Dispose();
            _isQueueLoading = false;
            _queueRefreshLock.Release();

            if (!_disposeCts.IsCancellationRequested)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private static string FormatQueueItem(SonosQueueItem item) => item.DisplayTitle;

    private void ShowCommandStatus(string message, bool isError = false, int autoHideMs = 3500)
    {
        _commandStatusMessage = message;
        _commandStatusIsError = isError;

        _commandStatusCts?.Cancel();
        _commandStatusCts?.Dispose();
        _commandStatusCts = new CancellationTokenSource();
        var token = _commandStatusCts.Token;

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(autoHideMs, token);
                if (!token.IsCancellationRequested)
                {
                    await InvokeAsync(() =>
                    {
                        _commandStatusMessage = null;
                        StateHasChanged();
                    });
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
            }
        }, token);
    }

    private void TrackSonosCommandError(string commandName, Exception ex)
    {
        MetricsCollector.IncrementSonosCommandError(commandName);
        Logger.LogWarning(ex, "Sonos command {CommandName} failed for speaker {SpeakerIp}.", commandName, SelectedSpeakerIp);
    }

    private async Task PlayMediaItem(string url, string type)
    {
        if (string.IsNullOrEmpty(url) || _settings is null) return;

        _loadingMediaUrl = url;
        await InvokeAsync(StateHasChanged);

        try
        {
            switch (type)
            {
                case "station":
                    await _uow.SonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, url);
                    await AddLog("Station Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"Station changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
                case "spotify":
                    await _uow.SonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
                    await AddLog("Spotify Track Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"Spotify track changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
                case "youtube":
                    await _uow.SonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, url, _settings.AutoPlayStationUrl);
                    await AddLog("YouTube Music Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"YouTube Music changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
            }
            await _uow.SonosConnectorRepo.StartPlaying(_settings.IP_Adress);
            ShowCommandStatus("Playback command sent.");
        }
        catch (Exception ex)
        {
            TrackSonosCommandError($"play_{type}", ex);
            ShowCommandStatus("Playback command failed. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _loadingMediaUrl = null;
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (!string.IsNullOrEmpty(spotifyUrl))
            {
                await PlaySpotifyTrack(spotifyUrl);
                spotifyUrl = string.Empty; // Clear the input field after submission
            }
        }
    }

    private async Task SubmitSpotifyUrl()
    {
        if (!string.IsNullOrWhiteSpace(spotifyUrl))
        {
            await PlaySpotifyTrack(spotifyUrl);
            spotifyUrl = string.Empty;
        }
    }

    private async Task PlaySpotifyTrack(string url)
    {
        if (_settings is not null)
        {
            _isSpotifyUrlLoading = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                await _uow.SonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
                await AddLog("Spotify URL Played", url);
                ShowCommandStatus("Spotify URL sent to Sonos.");
            }
            catch (Exception ex)
            {
                TrackSonosCommandError("spotify_url_play", ex);
                ShowCommandStatus("Spotify URL playback failed. Please retry.", isError: true, autoHideMs: 4500);
            }
            finally
            {
                _isSpotifyUrlLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task NextTrack()
    {
        _isNextTrackLoading = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            await _uow.SonosConnectorRepo.NextTrack(SelectedSpeakerIp);
            await AddLog("Next Track");
            ShowCommandStatus("Skipped to next track.");
        }
        catch (Exception ex)
        {
            TrackSonosCommandError("next_track", ex);
            ShowCommandStatus("Next-track command failed. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _isNextTrackLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OpenTimerModal()
    {
        timerErrorMessage = null;

        if (timerMinutes <= 0)
        {
            timerMinutes = 60;
        }

        isTimerModalOpen = true;
    }

    private void CloseTimerModal()
    {
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private async Task StartTimedPlayback()
    {
        timerErrorMessage = null;

        if (_settings is null)
        {
            timerErrorMessage = "Settings are not loaded.";
            return;
        }

        if (timerMinutes <= 0)
        {
            timerErrorMessage = "Please enter a duration greater than zero.";
            return;
        }

        if (string.IsNullOrWhiteSpace(timerSelection))
        {
            timerErrorMessage = "Please select a playback source.";
            return;
        }

        var parts = timerSelection.Split('|', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2)
        {
            timerErrorMessage = "Invalid selection.";
            return;
        }

        var selectionType = parts[0];
        var selectionValue = parts[1];
        string selectionName;
        string logSource;

        try
        {
            if (selectionType == "station")
            {
                var station = _stations.FirstOrDefault(s => s.Url == selectionValue);
                selectionName = station?.Name ?? selectionValue;
                logSource = $"Station: {selectionName}";
                await _uow.SonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = false;
            }
            else if (selectionType == "spotify")
            {
                var track = _tracks.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = track?.Name ?? selectionValue;
                logSource = $"Spotify: {selectionName}";
                await _uow.SonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = true;
            }
            else if (selectionType == "youtube")
            {
                var entry = _youTubeCollections.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = entry?.Name ?? selectionValue;
                logSource = $"YouTube Music: {selectionName}";
                await _uow.SonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, selectionValue, _settings.AutoPlayStationUrl);
                _isSpotifyPlaying = false;
            }
            else
            {
                timerErrorMessage = "Invalid source selected.";
                return;
            }

            await _uow.SonosConnectorRepo.StartPlaying(_settings.IP_Adress);
            _isPlaying = true;

            var minutes = timerMinutes;
            var ip = _settings.IP_Adress;

            _playbackTimerCts?.Cancel();
            _playbackTimerCts?.Dispose();
            _playbackTimerCts = null;

            await AddLog("Timed Playback Started", $"{logSource} ({minutes} minutes)");
            ShowCommandStatus($"Timed playback started for {minutes} minutes.");

            _timerSelectionName = selectionName;
            _timerEndTimeUtc = DateTime.UtcNow.AddMinutes(minutes);

            isTimerModalOpen = false;
            timerSelection = null;
            timerMinutes = 60;

            _playbackTimerCts = new CancellationTokenSource();
            var cts = _playbackTimerCts;

            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromMinutes(minutes), cts.Token);
                    await InvokeAsync(async () =>
                    {
                        await _uow.SonosConnectorRepo.PausePlaying(ip);
                        _isPlaying = false;
                        _timerEndTimeUtc = null;
                        _timerSelectionName = null;
                        await AddLog("Timed Playback Completed", $"{logSource} ({minutes} minutes)");
                        StateHasChanged();
                    });
                }
                catch (TaskCanceledException)
                {
                }
                finally
                {
                    if (ReferenceEquals(_playbackTimerCts, cts))
                    {
                        _playbackTimerCts = null;
                    }

                    cts.Dispose();
                }
            });
        }
        catch (Exception ex)
        {
            TrackSonosCommandError("timed_playback_start", ex);
            Console.Error.WriteLine(ex);
            timerErrorMessage = "Failed to start timed playback.";
            ShowCommandStatus("Failed to start timed playback. Please retry.", isError: true, autoHideMs: 4500);
        }
    }

    private async Task CancelTimedPlayback()
    {
        var cts = _playbackTimerCts;
        if (cts is not null)
        {
            _playbackTimerCts = null;
            cts.Cancel();
            cts.Dispose();
        }

        if (_timerEndTimeUtc is not null || _timerSelectionName is not null)
        {
            var stopInfo = _timerEndTimeUtc?.ToLocalTime().ToString("t");
            var details = _timerSelectionName ?? "Timed playback";
            if (!string.IsNullOrEmpty(stopInfo))
            {
                details += $" (scheduled stop at {stopInfo})";
            }

            await AddLog("Timed Playback Cancelled", details);
        }

        _timerEndTimeUtc = null;
        _timerSelectionName = null;
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private static string NormalizeColor(string? value, string fallback)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return fallback;
        }

        var trimmed = value.Trim();

        if (!trimmed.StartsWith("#", System.StringComparison.Ordinal))
        {
            trimmed = $"#{trimmed.TrimStart('#')}";
        }

        if (trimmed.Length == 7)
        {
            return trimmed;
        }

        if (trimmed.Length == 4)
        {
            return $"#{trimmed[1]}{trimmed[1]}{trimmed[2]}{trimmed[2]}{trimmed[3]}{trimmed[3]}";
        }

        if (trimmed.Length > 7)
        {
            return trimmed.Substring(0, 7);
        }

        return fallback;
    }

    private async Task AddLog(string action, string? details = null)
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var username = user.Identity?.Name ?? "Unknown";

        var log = new LogEntry
        {
            Action = action,
            PerformedBy = username,
            Timestamp = DateTime.UtcNow,
            Details = details
        };

        Db.Logs.Add(log);
        await Db.SaveChangesAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        isAuthenticated = user.Identity?.IsAuthenticated ?? false;
        if (!isAuthenticated)
        {
            Navigation.NavigateTo("/auth/login?", true);
            return;
        }

        _settings = await _uow.SettingsRepo.GetSettings() ?? new SonosSettings();
        _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();

        if (_settings.Speakers.Any())
        {
             // Use the first speaker or the last selected one if available
            if (string.IsNullOrEmpty(_selectedSpeakerIp) || !_settings.Speakers.Any(s => s.IpAddress == _selectedSpeakerIp))
            {
                 _selectedSpeakerIp = _settings.Speakers.First().IpAddress;
                 _settings.IP_Adress = _selectedSpeakerIp;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && isAuthenticated && _settings != null)
        {
            try
            {
                if (_settings.Speakers.Any() && _settings.IP_Adress != SonosSettings.DefaultPlaceholderIp)
                {
                    await Task.WhenAll(
                        EnsureVolumeAsync(),
                        EnsureSpeakerUuids(),
                        RequestPageRefreshAsync(forceSlowLane: true)
                    );

                    _stationUpdateTimer = new Timer(UpdatePageData, null, FastRefreshIntervalSeconds * 1000, FastRefreshIntervalSeconds * 1000);
                    ConfigureQueueAutoRefreshTimer();
                    await RefreshQueueAsync(reset: true);
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error in OnAfterRenderAsync: {ex}");
            }
        }
    }

    private async Task EnsureSpeakerUuids()
    {
        if (_settings?.Speakers == null) return;

        bool anyUpdated = false;
        foreach (var speaker in _settings.Speakers)
        {
            if (string.IsNullOrEmpty(speaker.Uuid))
            {
                var uuid = await _uow.SonosConnectorRepo.GetSpeakerUUID(speaker.IpAddress);
                if (!string.IsNullOrEmpty(uuid))
                {
                    speaker.Uuid = uuid;
                    anyUpdated = true;
                }
            }
        }

        if (anyUpdated)
        {
            await SaveSettings();
        }
    }

    private async Task EnsureVolumeAsync()
    {
        try
        {
            _settings!.Volume = await _uow.SonosConnectorRepo.GetVolume(SelectedSpeakerIp);
        }
        catch
        {
            // Ignore if speaker is offline
        }

        var maxVolumeLimit = MaxVolumeLimit;
        if (_settings!.Volume > maxVolumeLimit)
        {
            _settings.Volume = maxVolumeLimit;
            await _uow.SonosConnectorRepo.SetVolume(SelectedSpeakerIp, maxVolumeLimit);
        }

        await SaveSettings();
    }

    private async Task Play(bool play)
    {
        _isMainPlaybackLoading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            if (play)
            {
                await _uow.SonosConnectorRepo.StartPlaying(SelectedSpeakerIp);
                _isPlaying = true;
                await AddLog("Playback Started");
                await NotificationService.SendNotificationAsync($"Playback started on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                ShowCommandStatus("Playback started.");
            }
            else
            {
                await _uow.SonosConnectorRepo.PausePlaying(SelectedSpeakerIp);
                _isPlaying = false;
                await AddLog("Playback Paused");
                await NotificationService.SendNotificationAsync($"Playback paused on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                ShowCommandStatus("Playback paused.");
            }
        }
        catch (Exception ex)
        {
            TrackSonosCommandError(play ? "play" : "pause", ex);
            ShowCommandStatus("Playback command failed. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _isMainPlaybackLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SyncPlay()
    {
        if (_isSyncing) return;
        if (_settings?.Speakers == null || !_settings.Speakers.Any()) return;

        _isSyncing = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            var slaveIps = _settings.Speakers.Where(s => s.IpAddress != SelectedSpeakerIp).Select(s => s.IpAddress).ToList();
            await ApplyLegacySync(SelectedSpeakerIp, slaveIps);

            await AddLog("Sync Play Started (Cloned URI)", "All speakers");
            await NotificationService.SendNotificationAsync($"Sync Play triggered for all speakers (Legacy sync)", await GetCurrentUserAsync());
            ShowCommandStatus("Sync Play started for all speakers.");
        }
        catch (Exception ex)
        {
            TrackSonosCommandError("sync_play", ex);
            ShowCommandStatus("Sync Play failed. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ApplyLegacySync(string masterIp, IEnumerable<string> slaveIps)
    {
        var currentUri = await _uow.SonosConnectorRepo.GetCurrentStationAsync(masterIp);

        var tasks = slaveIps.Select(async slaveIp =>
        {
             if (currentUri.StartsWith("x-rincon-mp3radio://") || currentUri.StartsWith("http"))
            {
                await _uow.SonosConnectorRepo.SetTuneInStationAsync(slaveIp, currentUri);
            }

            await _uow.SonosConnectorRepo.StartPlaying(slaveIp);
        });

        await Task.WhenAll(tasks);
    }

    private void OpenGroupModal() => isGroupModalOpen = true;
    private void CloseGroupModal() => isGroupModalOpen = false;

    private async Task HandleCreateGroup(List<string> slaveIps)
    {
        if (slaveIps == null || !slaveIps.Any()) return;

        _isGrouping = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            // Stop slave speakers first to ensure clean grouping
            await Task.WhenAll(slaveIps.Select(ip => _uow.SonosConnectorRepo.StopPlaying(ip)));

            // Try to create the group via UPnP
            bool success = await _uow.SonosConnectorRepo.CreateGroup(SelectedSpeakerIp, slaveIps);

            if (success)
            {
                await AddLog("Group Created", $"Master: {SelectedSpeakerIp}, Slaves: {string.Join(", ", slaveIps)}");
                await NotificationService.SendNotificationAsync($"Group created with master {SelectedSpeakerIp}", await GetCurrentUserAsync());
                ShowCommandStatus("Speaker group created.");
            }
            else
            {
                Console.WriteLine("Native grouping failed. Falling back to legacy sync.");
                await AddLog("Group Creation Failed - Fallback", $"Master: {SelectedSpeakerIp}. Attempting legacy sync.");
                await ApplyLegacySync(SelectedSpeakerIp, slaveIps);
                await NotificationService.SendNotificationAsync($"Group failed (UPnP error). Fallback Sync started for {SelectedSpeakerIp}", await GetCurrentUserAsync());
                ShowCommandStatus("Native grouping failed; fallback sync started.", isError: true, autoHideMs: 4500);
            }

            isGroupModalOpen = false;
        }
        catch (Exception ex)
        {
            TrackSonosCommandError("group_create", ex);
            await AddLog("Group Creation Failed", ex.Message);
            await NotificationService.SendNotificationAsync($"Group creation failed for master {SelectedSpeakerIp}: {ex.Message}", await GetCurrentUserAsync());
            ShowCommandStatus("Group creation failed. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _isGrouping = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task UngroupCurrent()
    {
        _isUngrouping = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            await _uow.SonosConnectorRepo.UngroupSpeaker(SelectedSpeakerIp);
            await AddLog("Speaker Ungrouped", SelectedSpeakerIp);
            await NotificationService.SendNotificationAsync($"Speaker {SelectedSpeakerIp} ungrouped", await GetCurrentUserAsync());
            ShowCommandStatus("Speaker ungrouped.");
        }
        catch (Exception ex)
        {
            TrackSonosCommandError("ungroup_speaker", ex);
            ShowCommandStatus("Failed to ungroup speaker. Please retry.", isError: true, autoHideMs: 4500);
        }
        finally
        {
            _isUngrouping = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task<string> GetCurrentUserAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        return authState.User.Identity?.Name ?? "Unknown";
    }

    private async Task SaveSettings()
    {
        await _uow.SettingsRepo.WriteSettings(_settings!);
    }

    private void ShowAddStationModal() => _addMediaItemModal.Show("Add New Station");
    private void ShowAddSpotifyModal() => _addMediaItemModal.Show("Add New Spotify Item");
    private void ShowAddYouTubeModal() => _addMediaItemModal.Show("Add New YouTube Music Item");

    private async Task SaveNewMediaItem((string Name, string Url) data)
    {
        _addModalError = null;
        _settings ??= new SonosSettings();

        switch (_activeMediaTab)
        {
            case "stations":
                _settings.Stations ??= new List<TuneInStation>();
                if (_settings.Stations.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Station with this name or URL already exists.";
                    return;
                }
                _settings.Stations.Add(new TuneInStation { Name = data.Name, Url = data.Url });
                await AddLog("Station Added", $"{data.Name} ({data.Url})");
                break;
            case "spotify":
                _settings.SpotifyTracks ??= new List<SpotifyObject>();
                 if (_settings.SpotifyTracks.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Spotify item with this name or URL already exists.";
                    return;
                }
                _settings.SpotifyTracks.Add(new SpotifyObject { Name = data.Name, Url = data.Url });
                await AddLog("Spotify Track Added", $"{data.Name} ({data.Url})");
                break;
            case "youtube":
                _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();
                 if (_settings.YouTubeMusicCollections.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "YouTube item with this name or URL already exists.";
                    return;
                }
                _settings.YouTubeMusicCollections.Add(new YouTubeMusicObject { Name = data.Name, Url = data.Url });
                await AddLog("YouTube Music Link Added", $"{data.Name} ({data.Url})");
                break;
        }
        
        await SaveSettings();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveStation(TuneInStation station)
    {
        if (_settings?.Stations is null) return;

        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete station '{station.Name}'?");
        if (!confirmed) return;

        _settings.Stations.Remove(station);
        await SaveSettings();

        await AddLog("Station Removed", $"{station.Name} ({station.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveSpotifyTrack(SpotifyObject track)
    {
        if (_settings?.SpotifyTracks is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete track '{track.Name}'?");
        if (!confirmed) return;

        _settings.SpotifyTracks.Remove(track);
        await SaveSettings();

        await AddLog("Spotify Track Removed", $"{track.Name} ({track.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveYouTubeMusicEntry(YouTubeMusicObject entry)
    {
        if (_settings?.YouTubeMusicCollections is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete link '{entry.Name}'?");
        if (!confirmed) return;

        _settings.YouTubeMusicCollections.Remove(entry);
        await SaveSettings();

        await AddLog("YouTube Music Link Removed", $"{entry.Name} ({entry.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private bool _isShuffleLoading;

    private async Task ShuffleStation()
    {
        if (_settings?.Stations != null && _settings.Stations.Any())
        {
            _isShuffleLoading = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                var randomStation = _settings.Stations[Random.Shared.Next(_settings.Stations.Count)].Url;
                await PlayMediaItem(randomStation, "station");
            }
            finally
            {
                _isShuffleLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _disposeCts.Cancel();

        _stationUpdateTimer?.Dispose();
        _stationUpdateTimer = null;

        _queueRefreshTimer?.Dispose();
        _queueRefreshTimer = null;

        lock (_refreshSync)
        {
            _activeRefreshCts?.Cancel();
            _activeRefreshCts?.Dispose();
            _activeRefreshCts = null;
            _refreshPending = false;
            _refreshPendingSlowLane = false;
        }

        var queueRefreshCts = _queueRefreshCts;
        if (queueRefreshCts is not null)
        {
            _queueRefreshCts = null;
            queueRefreshCts.Cancel();
            queueRefreshCts.Dispose();
        }

        var commandStatusCts = _commandStatusCts;
        if (commandStatusCts is not null)
        {
            _commandStatusCts = null;
            commandStatusCts.Cancel();
            commandStatusCts.Dispose();
        }

        var playbackCts = _playbackTimerCts;
        if (playbackCts is not null)
        {
            _playbackTimerCts = null;
            playbackCts.Cancel();
            playbackCts.Dispose();
        }

        _disposeCts.Dispose();
        _refreshLoopLock.Dispose();
        _queueRefreshLock.Dispose();

        await ValueTask.CompletedTask;
    }
}
